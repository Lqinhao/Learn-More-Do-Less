* 递归
  * 主要思想:		

    * 递归的基本思想就是把规模大的问题转化为规模小的相似的子问题来解决。
  * 归纳法主要包含以下三个关键要素：
    * 步进表达式：问题蜕变成子问题的表达式 
    * 结束条件：什么时候可以不再使用步进表达式 
    * 直接求解表达式：在结束条件下能够直接计算返回值的表达式 
  * 递归的三要素:
    1. 明确递归终止条件；
    2. 给出递归终止时的处理办法；
    3. 提取重复的逻辑，缩小问题规模。	
  * 递归的注意事项
    * 递归一定要有出口,内存溢出
    * 递归次数不宜过多,内存溢出​		
  * 格式:	

    	模型一： 在递去的过程中解决问题
    	function recursion(大规模){
    		if (end_condition){      // 明确的递归终止条件
    			end;   // 简单情景
    		}else{            // 在将问题转换为子问题的每一步，解决该步中剩余部分的问题
    			solve;                // 递去
    			recursion(小规模);     // 递到最深处后，不断地归来
    		}
    	}
    	模型二： 在归来的过程中解决问题
    	function recursion(大规模){
    		if (end_condition){      // 明确的递归终止条件
    			end;   // 简单情景
    		}else{            // 先将问题全部描述展开，再由尽头“返回”依次解决每步中剩余部分的问题
    			recursion(小规模);     // 递去
    			solve;                // 归来
    		}
    	}

* File类

  * 作用:文件和目录路径名的抽象表示形式。File的实例一旦创建不可改变	

    * 构造方法:

      ```java
      File(String pathname):通过将给定路径字符串转换成抽象路径名来创建一个新File实例
      File(String parent,String child):根据parent路径名字符串和child路径字符串创建一个新File实例
      File(File parent,String child):根据parent路径和child路径创建一个新的file实例	
      ```

    * 方法:		

      * 创建方法:
        * createNewFile():创建文件
        * Mkdirs:创建次抽象路径指定的目录
      * 删除方法:
        * Delete():删除文件
        * 注意:删除一个文件夹的时候需要先删除文件下面的所有文件和文件夹​			
      * 获取功能:
        * Length():获取文件的字节数,不能获取文件夹的字节数
        * getName():获取文件名
        * getPath():获取路径名
        * getParent():获取父路径
        * getParentFile():获取父路径,返回的是File对象
        * List():这个目录下所有的文件名					
          * 注意:只有指向文件夹的file文件才能使用这个方法​					
        * Rename()修改文件或者文件名
        * listRoots():获取所有的根盘符
          ​			
      * 判断方法:				
        * Exists():判断文件或者文件夹是否存在					
        * isFile(0判断是否是文件				
        * isDirectory:判断是否是文件夹