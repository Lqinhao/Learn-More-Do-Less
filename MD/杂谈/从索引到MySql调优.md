# 从索引到 MySql 调优

--------------------

## 数据库索引

* 索引的基本知识
  * 数据结构以及特点
    * b+ 树内部节点没有指向关键字具体信息的指针，因此内部节点更小，这样一次读入内存的数据会包含更多的数据，这样相对而言能够减少 io 的次数
    * 因为每个存储真实关键字信息的节点都在叶子结点，所以不论查找哪个数据都会查找到叶子节点，因此查询数据的效率是一样的
    * 因为真实的书存储在叶子节点上，因此在进行遍历的时候只需要将叶子节点进行扫面即可
  * 索引文件的存储
    * MyISAM 引擎：索引和文件是分开存储的，创建的新索引最用的叶子叶子结点数据会直接指向数据
    * Innodb 引擎：索引和文件是共同存储的，创建新的索引最终还是会指向 id 的索引，再通过这个 id 的索引进行查找
  * 索引失效的情况
    * 模糊查询的时候索引会失效
    * 索引中无法存储 null 值，因此查询 isnull 的时候不会使用索引
    * 在使用 or 的时候也不会使用索引
    * 采用联合索引的时候，查询条件的顺序不同也会导致索引失效
* 锁
  * 行锁
  * 表锁
* 常见操作的底层实现
  * Join
    * 会自动选择小表去驱动大表。现在小表中查找出对应的数据后，再通过轮询的方式将查出来的结果，去另外的一个表中进行查询，并将最后的数据进行返回
  * Order By
    * 会将数据加载到 Sort Cache 中，如果缓存空间不足的时候，会将排序字段的数据加载进来进行排序，再建立索引指向真实数据，最后将数据返回。如果缓存空间足够大的时候，会把所有的数据都加载到内存中，进行排序之后直接从缓存中将数据返回回去。
  * limit
    * 基于排序之后进行限制。

## MySql 调优

* 常用的优化规则
  * 采用小结果驱动大结果
  * 只拿去需要的字段不要使用 * 进行查询
  * 避免太复杂的多表关联查询
  * 使用最有效的过滤条件
* 常见的分析步骤
  1. 定位到执行效率比较慢的 sql 
     * 可以通过aop切面来进行监控
  2. 通过 explain 来查看 sql 的执行计划
     * 注意查看 type 类型进行查看分析
  3. 分析执行计划，查看是否可以优化
     * 也不到太多的建立索引，维护索引也需要进行开销，可以考虑建立联合索引来进行瘦身