# 从数据一致性到zab协议

-------------

> 随着数据量的段增大，从最原始的单节点存储数据，发展到现在的多节点存储数据。但是伴随着数据的分布式存储，也带来了一些对应的问题。在现在如何保证数据的高可用和一致性成了新的问题。

* 分布式
  * 特点
    1. 分布性：程序部署的机器在时间和空间上存在随机性
    2. 并发性：对于同一个服务存在同时访问同时修改的情况
    3. 无序性：进程之间的消息通讯可能会出现顺序不一致
  * 问题
    1. 网络通讯：网络本身的不可靠导致通讯出现故障
    2. 网络分区：网络发生异常时只有部分节点能够通信
    3. 三态：除了普通的成功，失败，还有超时
    4. 分布式事务：对事物的控制
* cap理论

  - 在分布式系统中，不能同时满足Consistency(一致性)，Availability(可用性)，Partition tolerance(分区容错性)这三个基本需求，最多只能满足其中的两项。
* base理论

  - base理论是指，basically available(基本了用)，soft-state(软状态/柔性事物)，eventual consistency(最终一致性)。是基于cap定理演化而来。是对于cap中一致性和可用性权衡的结果。
* 数据一致性
  1. 强一致性
     - 就是修改后的数据，要立马能够在后续的操作中查询出来。并且持久存储。
  2. 弱一致性
     - 不要求修改的数据在后续的时间内能被看到，这种一般不会采用。
  3. 最终一致性
     - 要求修改后的数据，在后续的某个时间点之后，就能查询到，并且持久存储。
* 强一致性解决方案

  * ACID：在单节点情况下，通过数据库的一致性，原子性，隔离性，和持久性来保证数据的强一致性。
* 最终一致性解决方案
  1. 2pc:通过引入 tm 来管理 ap 。在第一阶段 tm 向 ap 发送事物内容，进行事物的执行和反馈 tm 。在第二阶段 tm 接收到反馈之后进行提交事务或者回滚事务的操作。
     - 问题：同步阻塞，tm 挂掉，以及一个 ap 没有回应则要回滚全部。
  2. 3pc：是在 2pc 的基础上进行改进的，将 2pc 的二阶段拆分成了两个阶段预提交阶段和提交阶段。减少了同步阻塞的时间，并加入了超时机制。
     - 问题：数据不一致问题。
  3. paxos：分为两个阶段
     * 预提交阶段
       * 由提议者提出一个提议，这个提议里面会有一个 k，这个 k 递增不重复。把k发送给所有的接收者。接受者根据自己的 MaxN 和 k 做比较，如果大于 MaxN > k 则返回 err 或者不返回。如果小于 MaxN < k 则根据下列情况返回，如果之前没有返回过则返回 pok，null，null。如果之前提交过，则返回 pok，acceptN，acceptV，如果提议者收到了半数以上的 pok 回复，则进入提交阶段。否则重复第一阶段。
     * 提交阶段
       * 提议者会提出 accept 请求，这个请求有预提交阶段的k和一个 v。这个v如果回复的都是 pok ，null，null 则  v 为随机值，否则v取最大 accetpN 对应的 acceptV。作为决议提交给接收者。接收者会比较k和 MaxN 的大小，如果 MaxN>k 则返回 err 或者不返回。否则返回 aok 并将 accetpN 和 acceptV 进行更新。当提议者受到半数的 aok 回复的时候，就算提交成功，并将数据同步给learn 。否则从预提交阶段重新开始。
  4. zab协议：两种模式
     * 崩溃恢复：会选举一个 zxid 最大的节点作为 leader（zxid 由 leaderid + tranSationId）
     * 原子广播：leader 会将数据发送到 follower 上，如果超过半数以上follower返回ok，则提交成功。 leader 提交 commit 指令，并提交自己

  